<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FE Installation Project Scheduler</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: Arial, Helvetica, sans-serif; background: #ff0000; min-height: 100vh; padding: 20px; }
        .container { max-width: 1400px; margin: 0 auto; background: rgba(255,255,255,0.95); border-radius: 20px; padding: 30px; box-shadow: 0 20px 60px rgba(0,0,0,0.3);}
        h1 { color: #ff0000; margin-bottom: 30px; text-align: center; font-size: 2.5em; font-family: Arial, Helvetica, sans-serif; background: none; -webkit-background-clip: unset; background-clip: unset; -webkit-text-fill-color: unset;}
        .tabs { display: flex; gap: 10px; margin-bottom: 30px; border-bottom: 2px solid #e0e0e0;}
        .tab { padding: 12px 24px; background: none; border: none; cursor: pointer; font-size: 16px; color: #666; transition: all 0.3s; border-bottom: 3px solid transparent; margin-bottom: -2px;}
        .tab.active { color: #ff0000; border-bottom-color: #ff0000; font-weight: 600;}
        .tab:hover { color: #ff0000;}
        .section { display: none; animation: fadeIn 0.5s;}
        .section.active { display: block;}
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px);} to { opacity: 1; transform: translateY(0);}}
        .form-grid { display: grid; grid-template-columns: repeat(auto-fit, min-content); grid-auto-rows: min-content; gap: 20px; margin-bottom: 20px;}
        .form-group { display: flex; flex-direction: column;}
        label { font-weight: 600; color: #555; margin-bottom: 8px; font-size: 14px;}
        input, select, textarea { padding: 12px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 15px; transition: all 0.3s;}
        input:focus, select:focus, textarea:focus { outline: none; border-color: #ff0000; box-shadow: 0 0 0 3px rgba(255,0,0,0.1);}
        textarea { resize: vertical; min-height: 100px;}
        .btn { padding: 12px 24px; background: linear-gradient(135deg, #ff0000, #b30000); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: 600; transition: all 0.3s; box-shadow: 0 4px 15px rgba(255,0,0,0.3);}
        .btn:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(255,0,0,0.4);}
        .btn-secondary { background: #6c757d; box-shadow: 0 4px 15px rgba(108,117,125,0.3);}
        .btn-danger { background: #dc3545; box-shadow: 0 4px 15px rgba(220,53,69,0.3);}
        .card { background: white; border-radius: 12px; padding: 20px; margin-bottom: 20px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); transition: all 0.3s;}
        .card:hover { box-shadow: 0 6px 20px rgba(0,0,0,0.15);}
        .card-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 2px solid #f0f0f0;}
        .card-title { font-size: 18px; font-weight: 600; color: #333;}
        .list-container { max-height: 500px; overflow-y: auto;}
        .schedule-output { background: #f8f9fa; border-radius: 12px; padding: 20px; margin-top: 20px; min-height: 200px;}
        .schedule-day { background: white; border-radius: 8px; padding: 15px; margin-bottom: 15px; border-left: 4px solid #ff0000;}
        .schedule-day h4 { color: #ff0000; margin-bottom: 10px;}
        .assignment { background: #fff0f0; padding: 10px; border-radius: 6px; margin-bottom: 8px;}
        .tech-tag { display: inline-block; background: #ff0000; color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px; margin-right: 5px;}
        .location-tag { display: inline-block; background: #b30000; color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px;}
        .scope-types { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px;}
        .scope-type-card { background: #f8f9fa; padding: 15px; border-radius: 8px; border: 2px solid #e0e0e0;}
        .scope-type-card h5 { color: #ff0000; margin-bottom: 10px;}
        .metrics { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-top: 20px;}
        .metric-card { background: linear-gradient(135deg, #ff0000, #b30000); color: white; padding: 20px; border-radius: 12px; text-align: center;}
        .metric-value { font-size: 32px; font-weight: bold; margin-bottom: 5px;}
        .metric-label { font-size: 14px; opacity: 0.9;}
        .error { background: #fee; color: #c33; padding: 10px; border-radius: 6px; margin-top: 10px;}
        .success { background: #efe; color: #3c3; padding: 10px; border-radius: 6px; margin-top: 10px;}
        .project-list-container {
            max-height: 250px;
            overflow-y: auto;
            margin-top: 15px;
        }
        .project-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid #eee;
        }
        .project-item:hover {
            background-color: #f8f8f8;
        }
    </style>
    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, collection, query, where, getDocs, onSnapshot, updateDoc, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        window.firebase = {
            initializeApp,
            getAuth,
            signInAnonymously,
            signInWithCustomToken,
            getFirestore,
            doc,
            getDoc,
            setDoc,
            collection,
            query,
            where,
            getDocs,
            onSnapshot,
            updateDoc,
            deleteDoc
        };
    </script>
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCzV7sB-aIL3-OL2Z5EMW9TXvVEYjox7mw&libraries=places" async defer></script>
    <!-- SheetJS for XLSX export -->
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
</head>
<body>
    <div class="container">
        <h1>FE Installation Project Scheduler</h1>
        <div class="tabs">
            <button class="tab active" type="button" data-tab="technicians">Technicians</button>
            <button class="tab" type="button" data-tab="locations">Locations</button>
            <button class="tab" type="button" data-tab="scopes">Scope Templates</button>
            <button class="tab" type="button" data-tab="schedule">Generate Schedule</button>
        </div>

        <!-- Technicians Section -->
        <div id="technicians" class="section active">
            <div class="card">
                <div class="card-header">
                    <h3 class="card-title">Add Technician Team</h3>
                </div>
                <div class="form-grid">
                    <div class="form-group">
                        <label>Base Location</label>
                        <input type="text" id="techLocation" placeholder="e.g., Downtown Hub">
                    </div>
                    <div class="form-group">
                        <label for="techAddress">Technician Address</label>
                        <input type="text" id="techAddress" name="techAddress" placeholder="e.g., 100 Main St, City, State ZIP" autocomplete="off" style="width:100%;" />
                    </div>
                    <div class="form-group">
                        <label>Number of Technicians</label>
                        <input type="number" id="techCount" min="1" value="1">
                    </div>
                    <div class="form-group">
                        <label>Team Name/ID</label>
                        <input type="text" id="techTeamName" placeholder="e.g., Team Alpha">
                    </div>
                    <div class="form-group">
                        <label>Availability (Days)</label>
                        <div id="techDaysCheckboxes" style="display: flex; flex-wrap: wrap; gap: 10px;">
                            <label><input type="checkbox" value="Monday" checked> Monday</label>
                            <label><input type="checkbox" value="Tuesday" checked> Tuesday</label>
                            <label><input type="checkbox" value="Wednesday" checked> Wednesday</label>
                            <label><input type="checkbox" value="Thursday" checked> Thursday</label>
                            <label><input type="checkbox" value="Friday" checked> Friday</label>
                            <label><input type="checkbox" value="Saturday"> Saturday</label>
                            <label><input type="checkbox" value="Sunday"> Sunday</label>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Working Hours</label>
                        <div style="display: flex; gap: 10px;">
                            <input type="time" id="techStartTime" value="08:00">
                            <input type="time" id="techEndTime" value="17:00">
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Specializations</label>
                        <input type="text" id="techSpecializations" placeholder="e.g., VG, DC, PA (comma separated)">
                    </div>
                </div>
                <button class="btn" id="addTechBtn" onclick="addTechnician()">Add Technician Team</button>
            </div>
            <div class="card">
                <div class="card-header">
                    <h3 class="card-title">Current Technician Teams</h3>
                </div>
                <div id="technicianList" class="list-container"></div>
            </div>
        </div>

        <!-- Locations Section -->
        <div id="locations" class="section">
            <div class="card">
                <div class="card-header">
                    <h3 class="card-title">Add Installation Location</h3>
                </div>
                <div class="form-grid">
                    <div class="form-group">
                        <label>Site ID</label>
                        <input type="text" id="locationId" placeholder="e.g., SITE-001">
                    </div>
                    <div class="form-group">
                        <label>Site Name</label>
                        <input type="text" id="locationName" placeholder="e.g., Main Street Branch">
                    </div>
                    <div class="form-group">
                        <label for="locationAddress">Full Address</label>
                        <input type="text" id="locationAddress" name="locationAddress" placeholder="123 Main St, City, State ZIP" autocomplete="off" style="width:100%;" />
                    </div>
                    <div class="form-group">
                        <label>Scope of Work</label>
                        <input type="text" id="locationScope" placeholder="e.g., 15 VG + DCs, 5 PAs">
                    </div>
                    <div class="form-group">
                        <label>Priority Level</label>
                        <select id="locationPriority">
                            <option value="High">High</option>
                            <option value="Medium" selected>Medium</option>
                            <option value="Low">Low</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Site Availability</label>
                        <input type="text" id="locationAvailability" placeholder="e.g., Mon-Fri 9AM-5PM">
                    </div>
                    <div class="form-group">
                        <label>Contact Person</label>
                        <input type="text" id="locationContact" placeholder="Name and phone">
                    </div>
                    <div class="form-group">
                        <label>Special Requirements</label>
                        <textarea id="locationNotes" placeholder="Access codes, parking info, etc."></textarea>
                    </div>
                </div>
                <button class="btn" onclick="addLocation()">Add Location</button>
            </div>
            <div class="card">
                <div class="card-header">
                    <h3 class="card-title">Current Locations</h3>
                </div>
                <div id="locationList" class="list-container"></div>
            </div>
        </div>

        <!-- Scopes Section -->
        <div id="scopes" class="section">
            <div class="card">
                <div class="card-header">
                    <h3 class="card-title">Define Scope Templates</h3>
                </div>
                <div class="form-grid">
                    <div class="form-group">
                        <label>Scope Type</label>
                        <input type="text" id="scopeType" placeholder="e.g., VG, DC, PA">
                    </div>
                    <div class="form-group">
                        <label>Duration per Unit (minutes)</label>
                        <input type="number" id="scopeDuration" min="1" placeholder="e.g., 30">
                    </div>
                    <div class="form-group">
                        <label>Required Tech Count</label>
                        <input type="number" id="scopeTechCount" min="1" value="1">
                    </div>
                    <div class="form-group">
                        <label>Complexity Factor</label>
                        <select id="scopeComplexity">
                            <option value="1">Simple (1x)</option>
                            <option value="1.5">Moderate (1.5x)</option>
                            <option value="2">Complex (2x)</option>
                        </select>
                    </div>
                </div>
                <button class="btn" onclick="addScope()">Add Scope Template</button>
            </div>
            <div class="card">
                <div class="card-header">
                    <h3 class="card-title">Current Scope Templates</h3>
                </div>
                <div id="scopeList" class="scope-types"></div>
            </div>
        </div>

        <!-- Schedule Section -->
        <div id="schedule" class="section">
            <div class="card">
                <div class="card-header">
                    <h3 class="card-title">Schedule Parameters</h3>
                </div>
                <div class="form-grid">
                    <div class="form-group" style="display:none">
                        <label>Average Drive Time (minutes)</label>
                        <input type="number" id="driveTime" value="30" min="0">
                    </div>
                    <div class="form-group">
                        <label>Optimization Strategy</label>
                        <select id="optimizationStrategy">
                            <option value="efficiency">Maximum Efficiency</option>
                            <option value="priority">Priority First</option>
                            <option value="balanced">Balanced Approach</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Install Window Start</label>
                        <input type="date" id="installWindowStart" value="">
                    </div>
                    <div class="form-group">
                        <label>Install Window End</label>
                        <input type="date" id="installWindowEnd" value="">
                    </div>
                </div>
                <div style="color:#888; font-size:13px; margin-bottom:10px;">
                    <em>Drive time is now automatically estimated based on technician and location addresses.<br>
                    Buffer time is now always automated (minimum 15 minutes before each job).</em>
                </div>
                <button class="btn" onclick="generateSchedule()">ðŸš€ Generate Optimal Schedule</button>
                <button class="btn btn-secondary" id="overrideBtn" onclick="overrideUnassignedSchedule()" style="margin-left:10px; display:none;">Override Parameters</button>
                <button class="btn" onclick="exportToXLSX()" style="margin-left: 10px;">Export to XLSX</button>
            </div>
            <div class="card">
                <div class="card-header">
                    <h3 class="card-title">Project Management</h3>
                </div>
                <div class="form-grid" style="grid-template-columns: minmax(200px, 1fr) auto auto;">
                    <input type="text" id="projectName" placeholder="Enter project name to save...">
                    <button class="btn" onclick="saveProject()">Save Project</button>
                    <button class="btn btn-secondary" onclick="loadProject()">Load Project</button>
                </div>
                <div id="projectList" class="project-list-container">
                    <p style="color:#888; text-align: center;">Loading saved projects...</p>
                </div>
            </div>
            <div class="metrics" id="metrics"></div>
            <div class="schedule-output" id="scheduleOutput">
                <h3>Generated Schedule will appear here...</h3>
            </div>
        </div>
    </div>
    <script>
        // Global variables for Firebase
        let db;
        let auth;
        let userId;

        // --- Data and UI Logic ---
        let technicians = [];
        let locations = [];
        let scopes = [];
        let currentLocationScopes = [];
        let editTechId = null;
        let editLocationId = null;

        // Add a global to store last unassigned locations
        let lastUnassignedLocations = [];

        // Store last generated schedule and assignments for override
        let lastSchedule = {};
        let lastAssignments = [];

        // --- Persistent Storage using Firestore ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        let firebaseConfig = {};
        if (typeof __firebase_config !== 'undefined') {
            try {
                firebaseConfig = JSON.parse(__firebase_config);
            } catch (e) {
                console.error("Error parsing __firebase_config:", e);
            }
        }

        async function setupFirebase() {
            if (!window.firebase || Object.keys(firebaseConfig).length === 0) {
                console.error("Firebase config is missing or invalid. Cannot initialize Firebase.");
                return;
            }

            const { initializeApp, getAuth, signInWithCustomToken, signInAnonymously, getFirestore } = window.firebase;
            const app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);

            if (typeof __initial_auth_token !== 'undefined') {
                try {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } catch (error) {
                    console.error("Error signing in with custom token:", error);
                    await signInAnonymously(auth);
                }
            } else {
                await signInAnonymously(auth);
            }
            userId = auth.currentUser?.uid || crypto.randomUUID();
            listenForProjects();
        }

        async function saveProject() {
            if (!db || !userId) {
                alert('Firebase not initialized. Cannot save.');
                return;
            }
            const projectName = document.getElementById('projectName').value.trim();
            if (!projectName) {
                alert('Please enter a project name.');
                return;
            }
            const projectData = {
                technicians,
                locations,
                scopes,
                timestamp: new Date()
            };
            const projectRef = window.firebase.doc(db, `artifacts/${appId}/users/${userId}/projects/${projectName}`);
            try {
                await window.firebase.setDoc(projectRef, projectData, { merge: true });
                alert(`Project '${projectName}' saved successfully!`);
            } catch (e) {
                console.error("Error saving project: ", e);
                alert("Failed to save project. Check console for details.");
            }
        }

        async function loadProject() {
            if (!db || !userId) {
                alert('Firebase not initialized. Cannot load.');
                return;
            }
            const projectName = document.getElementById('projectName').value.trim();
            if (!projectName) {
                alert('Please enter a project name to load.');
                return;
            }
            const projectRef = window.firebase.doc(db, `artifacts/${appId}/users/${userId}/projects/${projectName}`);
            try {
                const docSnap = await window.firebase.getDoc(projectRef);
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    technicians = data.technicians;
                    locations = data.locations;
                    scopes = data.scopes;
                    updateTechnicianList();
                    updateLocationList();
                    updateScopeList();
                    updateScheduleTabContent();
                    alert(`Project '${projectName}' loaded successfully!`);
                } else {
                    alert(`No project found with the name '${projectName}'.`);
                }
            } catch (e) {
                console.error("Error loading project: ", e);
                alert("Failed to load project. Check console for details.");
            }
        }
        
        async function listenForProjects() {
            if (!db || !userId) return;
            const projectListDiv = document.getElementById('projectList');
            const q = window.firebase.collection(db, `artifacts/${appId}/users/${userId}/projects`);
            window.firebase.onSnapshot(q, (querySnapshot) => {
                const projects = [];
                querySnapshot.forEach((doc) => {
                    projects.push(doc.id);
                });
                renderProjectList(projects);
            }, (error) => {
                console.error("Error listening to projects:", error);
                projectListDiv.innerHTML = `<p style="color:#c33; text-align: center;">Error loading projects. Check console.</p>`;
            });
        }
        
        function renderProjectList(projects) {
            const listDiv = document.getElementById('projectList');
            if (projects.length === 0) {
                listDiv.innerHTML = '<p style="color:#888; text-align: center;">No saved projects yet.</p>';
                return;
            }
            listDiv.innerHTML = `
                <p style="font-weight: bold; margin-bottom: 5px;">Saved Projects:</p>
                ${projects.map(name => `
                    <div class="project-item">
                        <span>${name}</span>
                        <div>
                            <button class="btn btn-secondary" onclick="document.getElementById('projectName').value='${name}'; loadProject();">Load</button>
                            <button class="btn btn-danger" onclick="deleteProject('${name}')">Delete</button>
                        </div>
                    </div>
                `).join('')}
            `;
        }
        
        async function deleteProject(name) {
             if (!db || !userId) {
                alert('Firebase not initialized. Cannot delete.');
                return;
            }
            if (!confirm(`Are you sure you want to delete project '${name}'?`)) {
                return;
            }
            const projectRef = window.firebase.doc(db, `artifacts/${appId}/users/${userId}/projects/${name}`);
            try {
                await window.firebase.deleteDoc(projectRef);
                alert(`Project '${name}' deleted.`);
            } catch (e) {
                console.error("Error deleting project: ", e);
                alert("Failed to delete project. Check console for details.");
            }
        }

        // --- Data Persistence (using Firestore now) ---
        function saveAllData() {
            // No longer needed for general data, as projects are explicitly saved
        }
        function loadAllData() {
            // No longer needed for general data, as projects are explicitly loaded
        }
        function getCurrentTabName() {
            const activeTab = document.querySelector('.tab.active');
            if (!activeTab) return 'technicians';
            return activeTab.getAttribute('data-tab');
        }
        function setCurrentTab(tabName) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
            const tabBtn = document.querySelector(`.tab[data-tab="${tabName}"]`);
            if (tabBtn) {
                tabBtn.classList.add('active');
                const section = document.getElementById(tabName);
                if (section) section.classList.add('active');
            }
            if (tabName === 'scopes') {
                updateScopeList();
            }
            if (tabName === 'schedule') {
                updateScheduleTabContent();
            }
        }

        // --- Tab Logic (robust, no inline onclick, fluid UI) ---
        document.addEventListener('DOMContentLoaded', function () {
            // Tab click handler
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', function () {
                    // Remove active from all tabs and sections
                    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
                    // Add active to clicked tab and corresponding section
                    tab.classList.add('active');
                    const tabName = tab.getAttribute('data-tab');
                    const section = document.getElementById(tabName);
                    if (section) section.classList.add('active');
                    // Save tab state
                    localStorage.setItem('currentTab', tabName);
                    // Always update content when switching tabs
                    if (tabName === 'scopes') {
                        updateScopeList();
                    }
                    if (tabName === 'schedule') {
                        updateScheduleTabContent();
                    }
                });
            });
            // Restore tab on load
            const savedTab = localStorage.getItem('currentTab') || 'technicians';
            setCurrentTab(savedTab);
        });
        
        window.addEventListener('DOMContentLoaded', function() {
            // Technician Address Autocomplete
            if (window.google && window.google.maps && window.google.maps.places) {
                const techInput = document.getElementById('techAddress');
                const techAutocomplete = new google.maps.places.Autocomplete(techInput, { types: ['address'] });
                techAutocomplete.setFields(['formatted_address']);
                techAutocomplete.addListener('place_changed', function() {
                    const place = techAutocomplete.getPlace();
                    if (place && place.formatted_address) {
                        techInput.value = place.formatted_address;
                    }
                });

                // Location Address Autocomplete
                const locInput = document.getElementById('locationAddress');
                const locAutocomplete = new google.maps.places.Autocomplete(locInput, { types: ['address'] });
                locAutocomplete.setFields(['formatted_address']);
                locAutocomplete.addListener('place_changed', function() {
                    const place = locAutocomplete.getPlace();
                    if (place && place.formatted_address) {
                        locInput.value = place.formatted_address;
                    }
                });
            }
        });

        // --- Scope List always updates ---
        function updateScopeList() {
            const list = document.getElementById('scopeList');
            if (!list) return;
            if (scopes.length === 0) {
                list.innerHTML = '<p style="color:#888;">No scope templates defined yet.</p>';
                return;
            }
            list.innerHTML = scopes.map(scope => `
                <div class="scope-type-card">
                    <h5>${scope.type}</h5>
                    <p><strong>Duration:</strong> ${scope.duration} min/unit</p>
                    <p><strong>Tech Required:</strong> ${scope.techCount}</p>
                    <p><strong>Complexity:</strong> ${scope.complexity}x</p>
                    <button class="btn btn-danger" onclick="removeScope(${scope.id})">Remove</button>
                </div>
            `).join('');
        }

        // --- Schedule Tab always shows content ---
        function updateScheduleTabContent() {
            const scheduleOutput = document.getElementById('scheduleOutput');
            if (!scheduleOutput) return;
            if (scopes.length === 0) {
                scheduleOutput.innerHTML = '<div class="error">Please define at least one scope template before generating a schedule.</div>';
            } else if (technicians.length === 0 || locations.length === 0) {
                scheduleOutput.innerHTML = '<div class="error">Please add at least one technician team and one location before generating a schedule.</div>';
            } else {
                scheduleOutput.innerHTML = '<h3>Generated Schedule will appear here...</h3>';
            }
            displayMetrics({}, []);
        }

        // --- Initialization ---
        window.addEventListener('DOMContentLoaded', function() {
            setupFirebase();
            updateTechnicianList();
            updateLocationList();
            updateScopeList();
            // Restore tab
            const savedTab = localStorage.getItem('currentTab') || 'technicians';
            setCurrentTab(savedTab);
            // Ensure scope and schedule sections are populated
            updateScopeList();
            updateScheduleTabContent();
        });

        // --- Technician CRUD ---
        function getSelectedTechDays() {
            return Array.from(document.querySelectorAll('#techDaysCheckboxes input[type="checkbox"]:checked')).map(cb => cb.value);
        }
        function setSelectedTechDays(days) {
            document.querySelectorAll('#techDaysCheckboxes input[type="checkbox"]').forEach(cb => {
                cb.checked = days.includes(cb.value);
            });
        }
        function addTechnician() {
            const location = document.getElementById('techLocation').value.trim();
            const address = document.getElementById('techAddress').value.trim();
            const count = parseInt(document.getElementById('techCount').value);
            const teamName = document.getElementById('techTeamName').value.trim();
            const days = getSelectedTechDays();
            const startTime = document.getElementById('techStartTime').value;
            const endTime = document.getElementById('techEndTime').value;
            const specializations = document.getElementById('techSpecializations').value.split(',').map(s => s.trim()).filter(Boolean);

            let errors = [];
            if (!location) errors.push("Base Location is required.");
            if (!address) errors.push("Technician Address is required.");
            if (!count || count < 1) errors.push("Number of Technicians must be at least 1.");
            if (!teamName) errors.push("Team Name/ID is required.");
            if (days.length === 0) errors.push("At least one availability day must be selected.");
            if (!startTime || !endTime) errors.push("Working hours are required.");
            if (technicians.some(t => t.teamName === teamName && t.id !== editTechId)) errors.push("Team Name/ID must be unique.");

            if (errors.length > 0) {
                alert("Please fix the following:\n" + errors.join("\n"));
                return;
            }

            if (editTechId !== null) {
                const idx = technicians.findIndex(t => t.id === editTechId);
                if (idx !== -1) {
                    technicians[idx] = { id: editTechId, location, address, count, teamName, days, startTime, endTime, specializations };
                }
                editTechId = null;
                document.getElementById('addTechBtn').textContent = "Add Technician Team";
            } else {
                const tech = { id: Date.now(), location, address, count, teamName, days, startTime, endTime, specializations };
                technicians.push(tech);
            }
            updateTechnicianList();
            clearTechForm();
        }
        function clearTechForm() {
            document.getElementById('techLocation').value = '';
            document.getElementById('techAddress').value = '';
            document.getElementById('techCount').value = '1';
            document.getElementById('techTeamName').value = '';
            document.getElementById('techSpecializations').value = '';
            setSelectedTechDays(['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']);
            document.getElementById('techStartTime').value = '08:00';
            document.getElementById('techEndTime').value = '17:00';
            editTechId = null;
            document.getElementById('addTechBtn').textContent = "Add Technician Team";
        }
        function updateTechnicianList() {
            const list = document.getElementById('technicianList');
            if (technicians.length === 0) {
                list.innerHTML = '<p style="color:#888;">No technician teams added yet.</p>';
                return;
            }
            list.innerHTML = technicians.map(tech => `
                <div class="card">
                    <div class="card-header">
                        <strong>${tech.teamName}</strong>
                        <div>
                            <button class="btn btn-secondary" onclick="editTechnician(${tech.id})">Edit</button>
                            <button class="btn btn-danger" onclick="removeTechnician(${tech.id})">Remove</button>
                        </div>
                    </div>
                    <div>
                        <p><strong>Location:</strong> ${tech.location}</p>
                        <p><strong>Address:</strong> ${tech.address || '-'}</p>
                        <p><strong>Team Size:</strong> ${tech.count} technicians</p>
                        <p><strong>Available:</strong> ${tech.days.join(', ')}</p>
                        <p><strong>Hours:</strong> ${tech.startTime} - ${tech.endTime}</p>
                        <p><strong>Providers/Certifications:</strong> ${tech.specializations.join(', ') || 'All'}</p>
                    </div>
                </div>
            `).join('');
        }
        function editTechnician(id) {
            const tech = technicians.find(t => t.id === id);
            if (!tech) return;
            document.getElementById('techLocation').value = tech.location;
            document.getElementById('techAddress').value = tech.address;
            document.getElementById('techCount').value = tech.count;
            document.getElementById('techTeamName').value = tech.teamName;
            document.getElementById('techSpecializations').value = tech.specializations.join(', ');
            setSelectedTechDays(tech.days);
            document.getElementById('techStartTime').value = tech.startTime;
            document.getElementById('techEndTime').value = tech.endTime;
            editTechId = id;
            document.getElementById('addTechBtn').textContent = "Save Technician Team";
            document.getElementById('techLocation').focus();
        }
        function removeTechnician(id) {
            technicians = technicians.filter(t => t.id !== id);
            updateTechnicianList();
        }

        // --- Location CRUD ---
        function addLocation() {
            const siteId = document.getElementById('locationId').value.trim();
            const name = document.getElementById('locationName').value.trim();
            const address = document.getElementById('locationAddress').value.trim();
            const scope = document.getElementById('locationScope').value.trim();
            const priority = document.getElementById('locationPriority').value;
            const availability = document.getElementById('locationAvailability').value.trim();
            const contact = document.getElementById('locationContact').value.trim();
            const notes = document.getElementById('locationNotes').value.trim();

            let errors = [];
            if (!siteId) errors.push("Site ID is required.");
            if (!address) errors.push("Full Address is required.");
            if (!scope) errors.push("Scope of Work is required.");
            if (locations.some(l => l.siteId === siteId && l.id !== editLocationId)) errors.push("Site ID must be unique.");

            const scopeItems = parseScope(scope);
            const missingScopes = scopeItems.filter(item =>
                !scopes.some(s =>
                    item.type.toLowerCase().includes(s.type.toLowerCase()) ||
                    s.type.toLowerCase().includes(item.type.toLowerCase())
                )
            );
            if (missingScopes.length > 0) {
                alert("Please fix the following:\n" + "Scope type(s) not defined: " + missingScopes.map(s => s.type).join(', '));
                return;
            }

            if (errors.length > 0) {
                alert("Please fix the following:\n" + errors.join("\n"));
                return;
            }

            if (editLocationId !== null) {
                const idx = locations.findIndex(l => l.id === editLocationId);
                if (idx !== -1) {
                    locations[idx] = { id: editLocationId, siteId, name, address, scope, priority, availability, contact, notes };
                }
                editLocationId = null;
                document.querySelector('button[onclick="addLocation()"]').textContent = "Add Location";
            } else {
                const location = { id: Date.now(), siteId, name, address, scope, priority, availability, contact, notes };
                locations.push(location);
            }
            updateLocationList();
            clearLocationForm();
        }
        function updateLocationList() {
            const list = document.getElementById('locationList');
            if (locations.length === 0) {
                list.innerHTML = '<p style="color:#888;">No locations added yet.</p>';
                return;
            }
            list.innerHTML = locations.map(loc => `
                <div class="card">
                    <div class="card-header">
                        <strong>${loc.siteId} - ${loc.name || 'Unnamed'}</strong>
                        <div>
                            <button class="btn btn-secondary" onclick="editLocation(${loc.id})">Edit</button>
                            <button class="btn btn-danger" onclick="removeLocation(${loc.id})">Remove</button>
                        </div>
                    </div>
                    <div>
                        <p><strong>Address:</strong> ${loc.address}</p>
                        <p><strong>Scope:</strong> ${loc.scope}</p>
                        <p><strong>Priority:</strong> <span class="tech-tag">${loc.priority}</span></p>
                        <p><strong>Availability:</strong> ${loc.availability}</p>
                        ${loc.contact ? `<p><strong>Contact:</strong> ${loc.contact}</p>` : ''}
                        ${loc.notes ? `<p><strong>Notes:</strong> ${loc.notes}</p>` : ''}
                    </div>
                </div>
            `).join('');
        }
        function editLocation(id) {
            const loc = locations.find(l => l.id === id);
            if (!loc) return;
            document.getElementById('locationId').value = loc.siteId;
            document.getElementById('locationName').value = loc.name;
            document.getElementById('locationAddress').value = loc.address;
            document.getElementById('locationScope').value = loc.scope;
            document.getElementById('locationPriority').value = loc.priority;
            document.getElementById('locationAvailability').value = loc.availability;
            document.getElementById('locationContact').value = loc.contact;
            document.getElementById('locationNotes').value = loc.notes;
            editLocationId = id;
            document.querySelector('button[onclick="addLocation()"]').textContent = "Save Location";
            document.getElementById('locationId').focus();
        }
        function removeLocation(id) {
            locations = locations.filter(l => l.id !== id);
            updateLocationList();
            clearLocationForm();
        }
        function clearLocationForm() {
            document.getElementById('locationId').value = '';
            document.getElementById('locationName').value = '';
            document.getElementById('locationAddress').value = '';
            document.getElementById('locationScope').value = '';
            document.getElementById('locationAvailability').value = '';
            document.getElementById('locationContact').value = '';
            document.getElementById('locationNotes').value = '';
            document.getElementById('locationPriority').value = 'Medium';
            editLocationId = null;
            document.querySelector('button[onclick="addLocation()"]').textContent = "Add Location";
            currentLocationScopes = [];
            if (typeof renderLocationScopeList === "function") renderLocationScopeList();
        }

        // --- Scope CRUD ---
        function addScope() {
            const type = document.getElementById('scopeType').value.trim();
            const duration = parseInt(document.getElementById('scopeDuration').value);
            const techCount = parseInt(document.getElementById('scopeTechCount').value);
            const complexity = parseFloat(document.getElementById('scopeComplexity').value);

            let errors = [];
            if (!type) errors.push("Scope Type is required.");
            if (!duration || duration < 1) errors.push("Duration per Unit must be at least 1.");
            if (!techCount || techCount < 1) errors.push("Required Tech Count must be at least 1.");
            if (!complexity || complexity < 1) errors.push("Complexity Factor must be at least 1.");
            if (scopes.some(s => s.type.toLowerCase() === type.toLowerCase())) errors.push("Scope Type must be unique.");

            if (errors.length > 0) {
                alert("Please fix the following:\n" + errors.join("\n"));
                return;
            }

            const scope = { id: Date.now(), type, duration, techCount, complexity };

            scopes.push(scope);
            updateScopeList();
            clearScopeForm();
        }
        function clearScopeForm() {
            document.getElementById('scopeType').value = '';
            document.getElementById('scopeDuration').value = '';
            document.getElementById('scopeTechCount').value = '1';
            document.getElementById('scopeComplexity').value = '1';
        }
        function updateScopeList() {
            const list = document.getElementById('scopeList');
            if (!list) return;
            if (scopes.length === 0) {
                list.innerHTML = '<p style="color:#888;">No scope templates defined yet.</p>';
                return;
            }
            list.innerHTML = scopes.map(scope => `
                <div class="scope-type-card">
                    <h5>${scope.type}</h5>
                    <p><strong>Duration:</strong> ${scope.duration} min/unit</p>
                    <p><strong>Tech Required:</strong> ${scope.techCount}</p>
                    <p><strong>Complexity:</strong> ${scope.complexity}x</p>
                    <button class="btn btn-danger" onclick="removeScope(${scope.id})">Remove</button>
                </div>
            `).join('');
        }
        function removeScope(id) {
            scopes = scopes.filter(s => s.id !== id);
            updateScopeList();
        }

        // --- Helper: Parse scope string into items ---
        function parseScope(scopeString) {
            const items = [];
            const parts = scopeString.split(',');
            parts.forEach(part => {
                const match = part.trim().match(/(\d+)\s*(.+)/);
                if (match) {
                    const [_, quantity, type] = match;
                    items.push({ quantity: parseInt(quantity), type: type.trim() });
                }
            });
            return items;
        }

        // --- Helper: Calculate job duration based on scope ---
        function calculateJobDuration(scopeString) {
            const scopeItems = parseScope(scopeString);
            let totalDuration = 0;
            scopeItems.forEach(item => {
                const scopeTemplate = scopes.find(s =>
                    item.type.toLowerCase().includes(s.type.toLowerCase()) ||
                    s.type.toLowerCase().includes(item.type.toLowerCase())
                );
                if (scopeTemplate) {
                    totalDuration += item.quantity * scopeTemplate.duration * scopeTemplate.complexity;
                } else {
                    totalDuration += item.quantity * 30; // fallback
                }
            });
            return totalDuration;
        }

        // --- Helper: Calculate driving time and distance using Google Maps Distance Matrix API ---
        async function getDriveInfo(origin, destination) {
            return new Promise((resolve) => {
                if (!origin || !destination) return resolve({minutes: 0, miles: 0});
                if (!window.google || !window.google.maps || !window.google.maps.DistanceMatrixService) return resolve({minutes: 30, miles: 10});
                const service = new google.maps.DistanceMatrixService();
                service.getDistanceMatrix(
                    {
                        origins: [origin],
                        destinations: [destination],
                        travelMode: google.maps.TravelMode.DRIVING,
                        unitSystem: google.maps.UnitSystem.IMPERIAL,
                    },
                    (response, status) => {
                        if (status === "OK" && response.rows[0].elements[0].status === "OK") {
                            const duration = response.rows[0].elements[0].duration.value; // seconds
                            const distance = response.rows[0].elements[0].distance.value; // meters
                            const miles = (distance / 1609.34).toFixed(1);
                            resolve({minutes: Math.round(duration / 60), miles: miles});
                        } else {
                            resolve({minutes: 30, miles: 10});
                        }
                    }
                );
            });
        }

        // --- Helper: Get available days for a location ---
        function getLocationAvailableDays(location) {
            const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
            if (!location.availability || location.availability.trim() === "") return days;
            return days.filter(day => location.availability.toLowerCase().includes(day.toLowerCase()));
        }

        // --- Helper: Get location available time window ---
        function getLocationAvailableTime(location) {
            let startHour = 8, startMin = 0, endHour = 17, endMin = 0;
            const timeMatch = location.availability && location.availability.match(/(\d{1,2})(?::(\d{2}))?\s*(am|pm)?\s*-\s*(\d{1,2})(?::(\d{2}))?\s*(am|pm)?/i);
            if (timeMatch) {
                startHour = parseInt(timeMatch[1]);
                startMin = timeMatch[2] ? parseInt(timeMatch[2]) : 0;
                if (timeMatch[3] && timeMatch[3].toLowerCase() === 'pm' && startHour < 12) startHour += 12;
                endHour = parseInt(timeMatch[4]);
                endMin = timeMatch[5] ? parseInt(timeMatch[5]) : 0;
                if (timeMatch[6] && timeMatch[6].toLowerCase() === 'pm' && endHour < 12) endHour += 12;
            }
            return { startHour, startMin, endHour, endMin };
        }
        
        // --- Helper function to format duration in hours and minutes ---
        function formatDuration(minutes) {
            if (minutes < 60) {
                return `${minutes} minutes`;
            }
            const hours = Math.floor(minutes / 60);
            const mins = minutes % 60;
            return `${hours} hour${hours > 1 ? 's' : ''}${mins > 0 ? `, ${mins} minute${mins > 1 ? 's' : ''}` : ''}`;
        }

        // --- Advanced Scheduling Logic ---
        async function generateSchedule() {
            if (technicians.length === 0 || locations.length === 0) {
                alert('Please add at least one technician team and one location');
                return;
            }
            if (scopes.length === 0) {
                alert('Please define at least one scope template.');
                return;
            }
            document.getElementById('scheduleOutput').innerHTML = '<h3>Generating schedule, please wait...</h3>';

            const strategy = document.getElementById('optimizationStrategy').value;
            let sortedLocations = [...locations];
            if (strategy === 'priority') {
                const priorityOrder = { 'High': 1, 'Medium': 2, 'Low': 3 };
                sortedLocations.sort((a, b) => priorityOrder[a.priority] - priorityOrder[b.priority]);
            }
            const schedule = {};
            const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
            let unassignedLocations = [];
            let assignments = [];

            const installWindowStart = document.getElementById('installWindowStart').value;
            const installWindowEnd = document.getElementById('installWindowEnd').value;
            let windowStart = installWindowStart ? new Date(installWindowStart + "T00:00:00") : null;
            let windowEnd = installWindowEnd ? new Date(installWindowEnd + "T23:59:59") : null;

            const today = new Date();
            let weekStart = windowStart ? new Date(windowStart) : new Date(today);
            weekStart.setHours(0,0,0,0);

            const driveInfoCache = {};
            async function getDriveInfoCached(origin, destination) {
                const key = `${origin}|${destination}`;
                if (driveInfoCache[key] !== undefined) return driveInfoCache[key];
                const info = await getDriveInfo(origin, destination);
                driveInfoCache[key] = info;
                return info;
            }

            const techUsage = {};
            for (const day of days) {
                techUsage[day] = {};
                technicians.forEach(tech => {
                    techUsage[day][tech.id] = 0;
                });
            }

            let locationsToSchedule = [...sortedLocations];
            
            while (locationsToSchedule.length > 0) {
                const location = locationsToSchedule.shift();
                let jobDurationMinutes = calculateJobDuration(location.scope);
                let scheduled = false;
                const availableDays = getLocationAvailableDays(location);

                for (const day of availableDays) {
                    const availableTeams = technicians.filter(tech => tech.days.includes(day));
                    if (availableTeams.length === 0) continue;

                    const scopeItems = parseScope(location.scope);
                    let requiredTechs = 0;
                    let requiredSpecializations = [];
                    scopeItems.forEach(item => {
                        const scopeTemplate = scopes.find(s =>
                            item.type.toLowerCase().includes(s.type.toLowerCase()) ||
                            s.type.toLowerCase().includes(item.type.toLowerCase())
                        );
                        if (scopeTemplate) {
                            requiredTechs = Math.max(requiredTechs, scopeTemplate.techCount);
                            requiredSpecializations.push(scopeTemplate.type);
                        }
                    });

                    let candidateTeams = availableTeams.filter(team => {
                        if (team.specializations.length > 0 && requiredSpecializations.length > 0) {
                            if (!requiredSpecializations.every(req =>
                                team.specializations.some(sp => sp.toLowerCase() === req.toLowerCase())
                            )) return false;
                        }
                        return (team.count - techUsage[day][team.id]) >= 1; // At least one tech available
                    });

                    if (candidateTeams.length === 0) continue;

                    candidateTeams.sort((a, b) => {
                        const aAvailable = a.count - (techUsage[day][a.id] || 0);
                        const bAvailable = b.count - (techUsage[day][b.id] || 0);
                        return bAvailable - aAvailable;
                    });
                    
                    const { startHour: locStartHour, startMin: locStartMin, endHour: locEndHour, endMin: locEndMin } = getLocationAvailableTime(location);
                    
                    const dayDate = new Date(weekStart);
                    dayDate.setDate(weekStart.getDate() + days.indexOf(day));
                    if (windowStart && dayDate < windowStart) continue;
                    if (windowEnd && dayDate > windowEnd) continue;

                    let assignedTeams = [];
                    let assignedTechCount = 0;
                    let primaryTeamDriveInfo = null;

                    for(const team of candidateTeams) {
                        const availableTechsInTeam = team.count - (techUsage[day][team.id] || 0);
                        if(availableTechsInTeam <= 0) continue;

                        const techsToAssign = Math.min(availableTechsInTeam, requiredTechs - assignedTechCount);
                        
                        if(techsToAssign > 0) {
                             if (!primaryTeamDriveInfo) {
                                 primaryTeamDriveInfo = await getDriveInfoCached(team.address, location.address);
                            }
                            assignedTeams.push({
                                teamId: team.id,
                                teamName: team.teamName,
                                assignedTechs: techsToAssign,
                                driveInfo: await getDriveInfoCached(team.address, location.address)
                            });
                            assignedTechCount += techsToAssign;
                            if (assignedTechCount >= requiredTechs) break;
                        }
                    }

                    if (assignedTechCount < requiredTechs) continue;
                    
                    const teamStart = candidateTeams[0].startTime.split(':');
                    const teamEnd = candidateTeams[0].endTime.split(':');
                    const dayStartTime = new Date(dayDate);
                    dayStartTime.setHours(Math.max(parseInt(teamStart[0]), locStartHour), Math.max(parseInt(teamStart[1]), locStartMin), 0, 0);
                    const dayEndTime = new Date(dayDate);
                    dayEndTime.setHours(Math.min(parseInt(teamEnd[0]), locEndHour), Math.min(parseInt(teamEnd[1]), locEndMin), 0, 0);

                    const availableWorkMinutes = (dayEndTime.getTime() - dayStartTime.getTime()) / 60000;
                    
                    if (availableWorkMinutes <= 0) continue;

                    const workToday = Math.min(jobDurationMinutes, availableWorkMinutes);

                    const jobStartTime = new Date(dayStartTime);
                    const jobEndTime = new Date(jobStartTime.getTime() + workToday * 60000);
                    
                    let newAssignment = {
                        location: location,
                        startDateTime: new Date(jobStartTime),
                        endDateTime: new Date(jobEndTime),
                        duration: workToday,
                        driveTime: primaryTeamDriveInfo.minutes,
                        driveMiles: primaryTeamDriveInfo.miles,
                        assignedTeams: assignedTeams,
                        day: day,
                        overrideParams: [],
                        requiredTechs: requiredTechs
                    };
                    
                    if (!schedule[day]) schedule[day] = { date: null, teams: [] };
                    if (!schedule[day].date) {
                        schedule[day].date = dayDate;
                    }

                    for(const assignedTeam of assignedTeams) {
                        let teamEntry = schedule[day].teams.find(t => t.team.id === assignedTeam.teamId);
                        if (!teamEntry) {
                            const originalTeam = technicians.find(t => t.id === assignedTeam.teamId);
                            teamEntry = { team: originalTeam, assignments: [] };
                            schedule[day].teams.push(teamEntry);
                        }
                        teamEntry.assignments.push(newAssignment);
                        techUsage[day][assignedTeam.teamId] += assignedTeam.assignedTechs;
                    }

                    assignments.push(newAssignment);
                    jobDurationMinutes -= workToday;
                    
                    if (jobDurationMinutes <= 0) {
                        scheduled = true;
                        break; 
                    } else {
                        location.scope = `${jobDurationMinutes} min remaining`;
                        locationsToSchedule.unshift(location);
                        break;
                    }
                }
                if (!scheduled) {
                    unassignedLocations.push(location);
                }
            }

            lastUnassignedLocations = unassignedLocations;
            lastSchedule = schedule;
            lastAssignments = assignments;

            displaySchedule(schedule, unassignedLocations, false);
            displayMetrics(schedule, unassignedLocations);
        }

        async function overrideUnassignedSchedule() {
            if (!lastUnassignedLocations || lastUnassignedLocations.length === 0) {
                alert('No unassigned locations to override.');
                return;
            }
            document.getElementById('scheduleOutput').innerHTML = '<h3>Overriding parameters for unassigned locations...</h3>';

            const installWindowStart = document.getElementById('installWindowStart').value;
            const installWindowEnd = document.getElementById('installWindowEnd').value;
            let windowStart = installWindowStart ? new Date(installWindowStart + "T00:00:00") : null;
            let windowEnd = installWindowEnd ? new Date(installWindowEnd + "T23:59:59") : null;

            const today = new Date();
            let weekStart = windowStart ? new Date(windowStart) : new Date(today);
            weekStart.setHours(0,0,0,0);

            const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
            const driveInfoCache = {};
            async function getDriveInfoCached(origin, destination) {
                const key = `${origin}|${destination}`;
                if (driveInfoCache[key] !== undefined) return driveInfoCache[key];
                const info = await getDriveInfo(origin, destination);
                driveInfoCache[key] = info;
                return info;
            }

            const techUsage = {};
            for (const day of days) {
                techUsage[day] = {};
                technicians.forEach(tech => {
                    techUsage[day][tech.id] = 0;
                });
            }

            let allAssignments = [...lastAssignments];
            let schedule = JSON.parse(JSON.stringify(lastSchedule));

            let unassignedCopy = [...lastUnassignedLocations];
            lastUnassignedLocations = [];

            while(unassignedCopy.length > 0){
                const location = unassignedCopy.shift();
                let jobDurationMinutes = calculateJobDuration(location.scope);
                let scheduled = false;
                const availableDays = getLocationAvailableDays(location);

                for (const day of days) {
                    // This is the key difference: we only schedule on days the location is available
                    if (!availableDays.includes(day)) continue;

                    const availableTeams = technicians.filter(team => team.days.includes(day));
                    if (availableTeams.length === 0) continue;

                    const scopeItems = parseScope(location.scope);
                    let requiredTechs = 0;
                    let requiredSpecializations = [];
                    scopeItems.forEach(item => {
                        const scopeTemplate = scopes.find(s =>
                            item.type.toLowerCase().includes(s.type.toLowerCase()) ||
                            s.type.toLowerCase().includes(item.type.toLowerCase())
                        );
                        if (scopeTemplate) {
                            requiredTechs = Math.max(requiredTechs, scopeTemplate.techCount);
                            requiredSpecializations.push(scopeTemplate.type);
                        }
                    });

                    let candidateTeams = availableTeams.filter(team => (team.count - techUsage[day][team.id] || 0) > 0);
                    if (candidateTeams.length === 0) continue;

                    candidateTeams.sort((a, b) => {
                        const aAvailable = a.count - (techUsage[day][a.id] || 0);
                        const bAvailable = b.count - (techUsage[day][b.id] || 0);
                        return bAvailable - aAvailable;
                    });

                    const { startHour: locStartHour, startMin: locStartMin, endHour: locEndHour, endMin: locEndMin } = getLocationAvailableTime(location);
                    
                    const dayDate = new Date(weekStart);
                    dayDate.setDate(weekStart.getDate() + days.indexOf(day));
                    
                    const teamStart = candidateTeams[0].startTime.split(':');
                    const teamEnd = candidateTeams[0].endTime.split(':');
                    const dayStartTime = new Date(dayDate);
                    dayStartTime.setHours(Math.max(parseInt(teamStart[0]), locStartHour), Math.max(parseInt(teamStart[1]), locStartMin), 0, 0);
                    const dayEndTime = new Date(dayDate);
                    dayEndTime.setHours(Math.min(parseInt(teamEnd[0]), locEndHour), Math.min(parseInt(teamEnd[1]), locEndMin), 0, 0);
                    
                    const availableWorkMinutes = (dayEndTime.getTime() - dayStartTime.getTime()) / 60000;
                    if (availableWorkMinutes <= 0) continue;

                    let assignedTeams = [];
                    let assignedTechCount = 0;
                    let primaryTeamDriveInfo = null;
                    let paramsBroken = [];
                    
                    for(const team of candidateTeams) {
                        const availableTechsInTeam = team.count - (techUsage[day][team.id] || 0);
                        if(availableTechsInTeam <= 0) continue;

                        const techsToAssign = Math.min(availableTechsInTeam, requiredTechs - assignedTechCount);

                        if(techsToAssign > 0) {
                            if (team.specializations.length > 0 && requiredSpecializations.length > 0) {
                                if (!requiredSpecializations.every(req => team.specializations.some(sp => sp.toLowerCase() === req.toLowerCase()))) {
                                    paramsBroken.push("Specialization");
                                }
                            }
                            if (!primaryTeamDriveInfo) {
                                primaryTeamDriveInfo = await getDriveInfoCached(team.address, location.address);
                            }
                            assignedTeams.push({
                                teamId: team.id,
                                teamName: team.teamName,
                                assignedTechs: techsToAssign,
                                driveInfo: await getDriveInfoCached(team.address, location.address)
                            });
                            assignedTechCount += techsToAssign;
                            if (assignedTechCount >= requiredTechs) break;
                        }
                    }

                    if (assignedTechCount < requiredTechs) continue;
                    
                    const workToday = Math.min(jobDurationMinutes, availableWorkMinutes);
                    const jobStartTime = new Date(dayStartTime);
                    const jobEndTime = new Date(jobStartTime.getTime() + workToday * 60000);

                    if ((windowStart && jobStartTime < windowStart) || (windowEnd && jobEndTime > windowEnd)) {
                        paramsBroken.push("Install Window");
                    }
                    
                    let newAssignment = {
                        location: location,
                        startDateTime: new Date(jobStartTime),
                        endDateTime: new Date(jobEndTime),
                        duration: workToday,
                        driveTime: primaryTeamDriveInfo.minutes,
                        driveMiles: primaryTeamDriveInfo.miles,
                        assignedTeams: assignedTeams,
                        day: day,
                        overrideParams: [...new Set(paramsBroken)],
                        requiredTechs: requiredTechs
                    };

                    if (!schedule[day]) schedule[day] = { date: null, teams: [] };
                    if (!schedule[day].date) {
                        schedule[day].date = dayDate;
                    }

                    for(const assignedTeam of assignedTeams) {
                        let teamEntry = schedule[day].teams.find(t => t.team.id === assignedTeam.teamId);
                        if (!teamEntry) {
                            const originalTeam = technicians.find(t => t.id === assignedTeam.teamId);
                            teamEntry = { team: originalTeam, assignments: [] };
                            schedule[day].teams.push(teamEntry);
                        }
                        teamEntry.assignments.push(newAssignment);
                        techUsage[day][assignedTeam.teamId] += assignedTeam.assignedTechs;
                    }

                    allAssignments.push(newAssignment);
                    jobDurationMinutes -= workToday;
                    
                    if (jobDurationMinutes <= 0) {
                        scheduled = true;
                        break; 
                    } else {
                        location.scope = `${jobDurationMinutes} min remaining`;
                        unassignedCopy.unshift(location);
                        break;
                    }
                }
                if (!scheduled) {
                    lastUnassignedLocations.push(location);
                }
            }

            displaySchedule(schedule, lastUnassignedLocations, true);
            displayMetrics(schedule, lastUnassignedLocations);
        }

        function displaySchedule(schedule, unassigned, overrideMode = false) {
            const output = document.getElementById('scheduleOutput');
            let html = '<h3>ðŸ“… Optimized Installation Schedule</h3>';
            Object.entries(schedule).forEach(([day, dayObj]) => {
                let { date, teams } = dayObj;
                if (date && typeof date === "string") {
                    let parsed = new Date(date);
                    if (!isNaN(parsed.getTime())) {
                        date = parsed;
                    } else {
                        date = new Date();
                    }
                }
                if (teams.length > 0) {
                    html += `<div class="schedule-day">`;
                    html += `<h4>${day} &mdash; ${date instanceof Date && !isNaN(date) ? date.toLocaleDateString(undefined, { weekday: 'long', year: 'numeric', month: 'short', day: 'numeric' }) : day}</h4>`;
                    teams.forEach(teamSchedule => {
                        html += `<div class="assignment">`;
                        html += `<p><strong>${teamSchedule.team.teamName}</strong> (Team Size: ${teamSchedule.team.count} techs)</p>`;
                        
                        const assignmentsForTeam = teamSchedule.assignments.filter(a => a.assignedTeams.some(at => at.teamId === teamSchedule.team.id));

                        assignmentsForTeam.forEach(assignment => {
                            const assignedTeam = assignment.assignedTeams.find(at => at.teamId === teamSchedule.team.id);

                            let startDT = assignment.startDateTime;
                            let endDT = assignment.endDateTime;

                            if (typeof startDT === 'string') {
                                startDT = new Date(startDT);
                            }
                            if (typeof endDT === 'string') {
                                endDT = new Date(endDT);
                            }

                            const startTime = startDT instanceof Date && !isNaN(startDT) ? startDT.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: true }) : startDT;
                            const endTime = endDT instanceof Date && !isNaN(endDT) ? endDT.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: true }) : endDT;
                            
                            html += `<div style="margin-left: 20px; margin-top: 10px;">`;
                            html += `<span class="tech-tag">${startTime}</span> - <span class="tech-tag">${endTime}</span>`;
                            html += `<span class="location-tag">${assignment.location.siteId}</span>`;
                            html += `<p><strong>Techs Assigned:</strong> ${assignedTeam.assignedTechs} from this team (Total for job: ${assignment.assignedTeams.reduce((sum, at) => sum + at.assignedTechs, 0)})</p>`;
                            html += `<p style="margin-top: 5px;">ðŸ“ ${assignment.location.address}</p>`;
                            html += `<p>ðŸ“‹ ${assignment.location.scope}</p>`;
                            html += `<p>â±ï¸ Est. Duration: ${formatDuration(assignment.duration)}</p>`;
                            html += `<p>ðŸš— Est. Drive: ${assignedTeam.driveInfo.miles} mi, ${assignedTeam.driveInfo.minutes} min</p>`;
                            if (assignment.overrideParams && assignment.overrideParams.length > 0) {
                                html += `<p style="color:#c33;"><strong>Override: </strong>Scheduled by breaking: ${assignment.overrideParams.join(', ')}</p>`;
                            }
                            html += `</div>`;
                        });
                        html += `</div>`;
                    });
                    html += `</div>`;
                }
            });
            if (!overrideMode && unassigned.length > 0) {
                html += `<div class="error">`;
                html += `<h4>âš ï¸ Unassigned Locations (${unassigned.length})</h4>`;
                unassigned.forEach(loc => {
                    html += `<p>â€¢ ${loc.siteId} - ${loc.address} (${loc.scope})</p>`;
                });
                html += `<p><strong>Reasons may include: insufficient techs, missing provider/certification, or site not available that day.</strong></p>`;
                html += `<p><strong>Consider adding more technician teams, updating certifications, or extending working hours.</strong></p>`;
                html += `<button class="btn btn-secondary" id="overrideBtn" onclick="overrideUnassignedSchedule()" style="margin-top:10px;">Override Parameters for Unassigned</button>`;
                html += `</div>`;
            } else if(overrideMode && unassigned.length > 0) {
                html += `<div class="error">`;
                html += `<h4>âš ï¸ Still Unassigned Locations (${unassigned.length})</h4>`;
                unassigned.forEach(loc => {
                    html += `<p>â€¢ ${loc.siteId} - ${loc.address} (${loc.scope})</p>`;
                });
                html += `<p><strong>Even with relaxed parameters, these locations could not be scheduled.</strong></p>`;
                html += `</div>`;
            }
            output.innerHTML = html;
        }

        // --- Metrics Display ---
        function displayMetrics(schedule, unassigned) {
            const metricsDiv = document.getElementById('metrics');
            if (!metricsDiv) return;

            let totalJobs = 0;
            let totalDriveMinutes = 0;
            let totalDriveMiles = 0;
            let totalDuration = 0;
            let totalTeams = 0;

            const countedJobs = new Set();
            const countedTeams = new Set();
            
            if (schedule && typeof schedule === 'object') {
                Object.values(schedule).forEach(dayObj => {
                    if (dayObj.teams) {
                        dayObj.teams.forEach(teamSchedule => {
                            countedTeams.add(teamSchedule.team.id);
                            teamSchedule.assignments.forEach(a => {
                                const jobId = `${a.location.id}-${a.day}-${a.startDateTime.getTime()}`;
                                if (!countedJobs.has(jobId)) {
                                    totalJobs++;
                                    totalDriveMinutes += Number(a.driveTime) || 0;
                                    totalDriveMiles += Number(a.driveMiles) || 0;
                                    totalDuration += Number(a.duration) || 0;
                                    countedJobs.add(jobId);
                                }
                            });
                        });
                    }
                });
            }
            totalTeams = countedTeams.size;

            metricsDiv.innerHTML = `
                <div class="metric-card">
                    <div class="metric-value">${totalJobs}</div>
                    <div class="metric-label">Total Jobs Scheduled</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value">${totalTeams}</div>
                    <div class="metric-label">Teams Utilized</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value">${totalDriveMiles.toFixed(1)}</div>
                    <div class="metric-label">Total Drive Miles</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value">${totalDriveMinutes}</div>
                    <div class="metric-label">Total Drive Minutes</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value">${totalDuration}</div>
                    <div class="metric-label">Total Installation Minutes</div>
                </div>
                ${unassigned && unassigned.length > 0 ? `
                <div class="metric-card" style="background: #dc3545;">
                    <div class="metric-value">${unassigned.length}</div>
                    <div class="metric-label">Unassigned Locations</div>
                </div>
                ` : ''}
            `;

            const overrideBtn = document.getElementById('overrideBtn');
            if (overrideBtn) {
                overrideBtn.style.display = unassigned.length > 0 ? 'inline-block' : 'none';
            }
        }

        // --- Export to XLSX Functionality ---
        function exportToXLSX() {
            if (Object.keys(lastSchedule).length === 0) {
                alert("Please generate a schedule before exporting.");
                return;
            }

            const data = [];
            let sheetName = "Schedule";
            let filename = "schedule.xlsx";

            const header = [
                "Date",
                "Day",
                "Team Name",
                "Team Size",
                "Assigned Techs",
                "Start Time",
                "End Time",
                "Site ID",
                "Address",
                "Scope of Work",
                "Duration (min)",
                "Drive Time (min)",
                "Drive Distance (mi)",
                "Override Reasons"
            ];
            data.push(header);

            Object.entries(lastSchedule).forEach(([day, dayObj]) => {
                dayObj.teams.forEach(teamSchedule => {
                    teamSchedule.assignments.forEach(assignment => {
                        const assignedTeamData = assignment.assignedTeams.find(t => t.teamId === teamSchedule.team.id);
                        const row = [
                            new Date(dayObj.date).toLocaleDateString(),
                            day,
                            teamSchedule.team.teamName,
                            teamSchedule.team.count,
                            assignedTeamData.assignedTechs,
                            new Date(assignment.startDateTime).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: true }),
                            new Date(assignment.endDateTime).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: true }),
                            assignment.location.siteId,
                            assignment.location.address,
                            assignment.location.scope,
                            assignment.duration,
                            assignedTeamData.driveInfo.minutes,
                            assignedTeamData.driveInfo.miles,
                            assignment.overrideParams.join(', ')
                        ];
                        data.push(row);
                    });
                });
            });

            if (lastUnassignedLocations.length > 0) {
                 const unassignedHeader = ["Unassigned Locations", "", "", "", "", "", "", "", "", "", "", "", "", ""];
                 data.push([]);
                 data.push(unassignedHeader);
                 lastUnassignedLocations.forEach(loc => {
                     data.push([
                         "",
                         "",
                         "",
                         "",
                         "",
                         "",
                         "",
                         loc.siteId,
                         loc.address,
                         loc.scope,
                         "",
                         "",
                         "",
                         ""
                     ]);
                 });
            }

            const wb = XLSX.utils.book_new();
            const ws = XLSX.utils.aoa_to_sheet(data);
            XLSX.utils.book_append_sheet(wb, ws, sheetName);
            XLSX.writeFile(wb, filename);
        }

    </script>
</body>
</html>
